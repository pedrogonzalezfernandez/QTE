#include "ext.h"#include "ext_obex.h"#include <stdlib.h>#include <math.h>typedef struct _initstate_calc {    t_object ob;    long n;    // number of eigenstates (and length of each state vector)    void *out; // outlet pointer} t_initstate_calc;void *initstate_calc_new(t_symbol *s, long argc, t_atom *argv);void initstate_calc_free(t_initstate_calc *x);void initstate_calc_assist(t_initstate_calc *x, void *b, long m, long a, char *s);void initstate_calc_list(t_initstate_calc *x, t_symbol *s, long argc, t_atom *argv);void ext_main(void *r) {    t_class *c;    c = class_new("initstate_calc", (method)initstate_calc_new, (method)initstate_calc_free, sizeof(t_initstate_calc), 0L, A_GIMME, 0);    class_addmethod(c, (method)initstate_calc_list, "list", A_GIMME, 0);    class_addmethod(c, (method)initstate_calc_assist, "assist", A_CANT, 0);    class_register(CLASS_BOX, c);}void *initstate_calc_new(t_symbol *s, long argc, t_atom *argv) {    t_initstate_calc *x = (t_initstate_calc *)object_alloc(/* class pointer */);    if(x){        x->n = 3; // default        if(argc > 0 && atom_gettype(argv) == A_LONG)            x->n = atom_getlong(argv);        x->out = outlet_new(x, NULL);    }    return (x);}void initstate_calc_free(t_initstate_calc *x) { }void initstate_calc_assist(t_initstate_calc *x, void *b, long m, long a, char *s) {    if(m==1)        sprintf(s, "Input: eigenstates & initial state vector");    else        sprintf(s, "Output: Coefficients R_k (each as a pair)");}void initstate_calc_list(t_initstate_calc *x, t_symbol *s, long argc, t_atom *argv) {    // For simplicity, assume:    // - First: eigenstates data: n eigenstates, each with n pairs (2 numbers per element), so total = n*n*2 numbers.    // - Then: initial state vector: n pairs (n*2 numbers).    long n = x->n;    long eigen_count = n * n * 2;    long init_count = n * 2;    if(argc != eigen_count + init_count) {        object_post((t_object *)x, "Expected %ld numbers", eigen_count + init_count);        return;    }    t_atom *out_list = (t_atom *)sysmem_newptr(n * 2 * sizeof(t_atom));    for(long k = 0; k < n; k++){        double re = 0, im = 0;        for(long i = 0; i < n; i++){            double e_re = atom_getfloat(argv + (k*n*2 + i*2));            double e_im = atom_getfloat(argv + (k*n*2 + i*2 + 1));            double psi_re = atom_getfloat(argv + eigen_count + i*2);            double psi_im = atom_getfloat(argv + eigen_count + i*2 + 1);            // Hermitian inner product: <psi, eigen_k> = sum(conj(e_k) * psi)            re += e_re * psi_re + e_im * psi_im;            im += e_re * psi_im - e_im * psi_re;        }        atom_setfloat(out_list + k*2, re);        atom_setfloat(out_list + k*2 + 1, im);    }    outlet_list(x->out, gensym("list"), n*2, out_list);    sysmem_freeptr(out_list);}